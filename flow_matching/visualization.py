from pathlib import Path

import matplotlib.animation as animation
import matplotlib.cm as cm
import matplotlib.pyplot as plt
import numpy as np
import torch
from torch.distributions import Independent, Normal

from flow_matching.datasets import SyntheticDataset
from flow_matching.solver import ModelWrapper, ODESolver


def plot_ode_sampling_evolution(
    flow: ModelWrapper,
    dataset: SyntheticDataset,
    num_samples: int = 1_000_000,
    step_size: float = 0.05,
    sample_steps: int = 10,
    output_dir: str = ".",
    filename: str = "sampling.png",
):
    """
    Visualize the evolution of samples generated by an ODE solver over time.

    This function samples points from a flow model using an ODE solver and creates
    a series of 2d histograms similar to the fig. 4 in the paper: https://arxiv.org/abs/2210.02747
    to visualize the distribution at different time steps.

    Args:
        flow (ModelWrapper): The flow model to sample from.
        dataset (SyntheticDataset): The dataset used to determine the square range for plotting.
        num_samples (int, optional): The number of samples to generate. Default is 1,000,000.
        step_size (float, optional): The step size for the ODE solver. Default is 0.05.
        sample_steps (int, optional): The number of time steps to sample. Default is 10.
        output_dir (str, optional): The directory where the output image will be saved. Default is the current directory.
        filename (str, optional): The name of the output image file. Default is "sampling.png".
    """

    output_dir = Path(output_dir)
    output_dir.mkdir(parents=True, exist_ok=True)

    flow.eval()
    device = next(flow.parameters()).device

    x_init = torch.randn((num_samples, 2), dtype=torch.float32, device=device)
    time_grid = torch.linspace(0, 1, sample_steps).to(device)  # sample times
    solver = ODESolver(flow)
    sol = solver.sample(
        x_init=x_init, step_size=step_size, method="midpoint", time_grid=time_grid, return_intermediates=True
    )
    sol = sol.detach().cpu().numpy()
    time_grid = time_grid.cpu()
    square_range = dataset.get_square_range(samples=torch.from_numpy(sol[-1]))

    fig, axes = plt.subplots(1, sample_steps, figsize=(2 * sample_steps, 2))

    for i in range(sample_steps):
        H = axes[i].hist2d(sol[i, :, 0], sol[i, :, 1], bins=300, range=square_range)
        cmin = 0.0
        cmax = torch.quantile(torch.from_numpy(H[0]), 0.99).item()
        norm = cm.colors.Normalize(vmax=cmax, vmin=cmin)
        axes[i].hist2d(sol[i, :, 0], sol[i, :, 1], bins=300, norm=norm, range=square_range)
        axes[i].set_aspect("equal")
        axes[i].axis("off")
        axes[i].set_title(f"t = {time_grid[i]:.2f}")

    plt.tight_layout()
    plt.savefig(output_dir / filename, bbox_inches="tight")
    print("Sampling results with ODE solver saved to", output_dir / filename)


def save_vector_field_and_samples_as_gif(
    flow: ModelWrapper,
    dataset: SyntheticDataset,
    sample_steps: int = 101,
    grid_size: int = 15,
    num_samples: int = 500000,
    interval: int = 50,
    output_dir: str = ".",
    filename: str = "vector_density_samples.gif",
):
    """
    Generate and save a GIF animation of the vector field and sampled trajectories.

    This function samples trajectories from a flow model using an ODE solver and visualizes
    the vector field along with the samples at different time steps, saving the result as a GIF.

    Args:
        flow (ModelWrapper): The flow model used for generating vector fields.
        dataset (SyntheticDataset): The dataset used to determine the range for the vector field.
        sample_steps (int, optional): The number of time steps for sampling. Default is 101.
        grid_size (int, optional): The size of the grid for the vector field. Default is 15.
        num_samples (int, optional): The number of samples to generate. Default is 500,000.
        interval (int, optional): The interval between frames in milliseconds. Default is 50.
        output_dir (str, optional): The directory to save the GIF. Default is the current directory.
        filename (str, optional): The name of the output GIF file. Default is "vector_density_samples.gif".
    """

    flow.eval()
    output_dir = Path(output_dir)
    output_dir.mkdir(parents=True, exist_ok=True)

    # Create a grid for the density and vector field
    x_range, y_range = dataset.get_square_range()
    x = np.linspace(x_range[0], x_range[1], grid_size)
    y = np.linspace(y_range[0], y_range[1], grid_size)
    xv, yv = np.meshgrid(x, y)
    grid = np.stack([xv, yv], axis=-1).reshape(-1, 2)  # Shape: (grid_size^2, 2)

    device = next(flow.parameters()).device
    grid_tensor = torch.tensor(grid, dtype=torch.float32, device=device)
    time_steps = torch.linspace(0, 1, sample_steps).to(device)

    step_size = 0.05
    x_init = torch.randn((num_samples, 2), dtype=torch.float32, device=device)
    solver = ODESolver(flow)
    sol = solver.sample(
        x_init=x_init, step_size=step_size, method="midpoint", time_grid=time_steps, return_intermediates=True
    )
    sol = sol.detach().cpu().numpy()

    # Create a figure with two subplots
    fig, axes = plt.subplots(1, 2, figsize=(12, 6))

    def update(frame):
        for ax in axes:
            ax.clear()

        # Current time step
        t = time_steps[frame]
        t_tensor = torch.full((grid_tensor.size(0), 1), t, device=device)

        # Compute vector field at time t
        vectors = flow(grid_tensor, t_tensor).detach().cpu().numpy()
        vectors = vectors.reshape(grid_size, grid_size, 2)
        magnitudes = np.linalg.norm(vectors, axis=2)

        # Normalize for coloring
        norm_vectors = plt.Normalize(magnitudes.min(), magnitudes.max())
        # Flatten magnitudes to 1D array for quiver
        magnitudes_flat = magnitudes.ravel()
        # Define width proportional to vector magnitudes
        width = np.clip(magnitudes_flat / magnitudes_flat.max() * 0.01, 0.002, 0.02)

        # Plot the vector field
        axes[0].quiver(
            xv,
            yv,
            vectors[:, :, 0],
            vectors[:, :, 1],
            magnitudes_flat,
            angles="xy",
            scale_units="xy",
            scale=8.0,  # Adjust scale to control arrow length
            cmap=cm.coolwarm,
            norm=norm_vectors,
            alpha=0.8,
            width=width.mean(),  # Single scalar value or consistent width
        )
        axes[0].set_xlim(x_range)
        axes[0].set_ylim(y_range)
        axes[0].set_title(f"Vector Field (t = {t.item():.2f})", fontsize=16)
        axes[0].set_aspect("equal")
        axes[0].axis("off")

        # Plot the ODE solver samples
        samples = sol[frame]
        axes[1].hist2d(samples[:, 0], samples[:, 1], bins=500, range=[x_range, y_range], cmap="viridis")
        axes[1].set_title(f"Samples (t = {t.item():.2f})", fontsize=16)
        axes[1].set_xlim(x_range)
        axes[1].set_ylim(y_range)
        axes[1].set_aspect("equal")
        axes[1].axis("off")

    # Adjust layout to reduce white space
    # plt.subplots_adjust(left=0.02, right=0.98, top=0.95, bottom=0.05, wspace=0.1)
    fig.tight_layout()

    # Create and save the animation as a GIF
    ani = animation.FuncAnimation(fig, update, frames=sample_steps, interval=interval)
    path = output_dir / filename
    ani.save(path, writer="pillow")
    print(f"Animation saved to {path}")


def plot_likelihood(
    flow: ModelWrapper,
    dataset: SyntheticDataset,
    output_dir: str = "./",
    filename: str = "likelihood.png",
):
    # Adapted from https://github.com/facebookresearch/flow_matching/blob/main/examples/2d_flow_matching.ipynb

    output_dir = Path(output_dir)
    output_dir.mkdir(parents=True, exist_ok=True)

    flow.eval()
    device = next(flow.parameters()).device

    # sample with likelihood
    step_size = 0.05

    square_range = dataset.get_square_range()
    extent = sum(square_range, [])  # flatten
    grid_size = 200
    x_1 = torch.meshgrid(
        torch.linspace(extent[1], extent[0], grid_size),
        torch.linspace(extent[2], extent[3], grid_size),
        indexing="ij",
    )
    x_1 = torch.stack([x_1[0].flatten(), x_1[1].flatten()], dim=1).to(device)

    # source distribution is an isotropic gaussian
    gaussian_log_density = Independent(Normal(torch.zeros(2, device=device), torch.ones(2, device=device)), 1).log_prob

    solver = ODESolver(flow)

    # compute log likelihood with unbiased hutchinson estimator, average over num_acc
    num_acc = 10
    log_p_acc = 0

    for _ in range(num_acc):
        _, log_p = solver.compute_likelihood(
            x_1=x_1, method="midpoint", step_size=step_size, exact_divergence=False, log_p0=gaussian_log_density
        )
        log_p_acc += log_p
    log_p_acc /= num_acc

    # compute with exact divergence
    sol, exact_log_p = solver.compute_likelihood(
        x_1=x_1,
        method="midpoint",
        step_size=step_size,
        exact_divergence=True,
        log_p0=gaussian_log_density,
        return_intermediates=True,
    )
    sol = sol.detach().cpu().numpy()

    # plot
    likelihood = torch.exp(log_p_acc).cpu().reshape(grid_size, grid_size).detach().numpy().T
    exact_likelihood = torch.exp(exact_log_p).cpu().reshape(grid_size, grid_size).detach().numpy().T

    fig, axs = plt.subplots(1, 2, figsize=(10, 6))

    cmin = 0.0
    cmax = 1 / 32  # 1/32 is the gt likelihood value

    norm = cm.colors.Normalize(vmax=cmax, vmin=cmin)

    axs[0].imshow(likelihood, extent=extent, origin="upper", cmap="viridis", norm=norm)
    axs[0].set_title(f"Model Likelihood, Hutchinson Estimator, #acc={num_acc}")
    axs[1].imshow(exact_likelihood, extent=extent, origin="upper", cmap="viridis", norm=norm)
    axs[1].set_title("Exact Model Likelihood")

    fig.colorbar(cm.ScalarMappable(norm=norm, cmap="viridis"), ax=axs, orientation="horizontal", label="density")

    plt.savefig(output_dir / filename)
    print("Likelihood saved to", output_dir / filename)
